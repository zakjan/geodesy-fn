{"version":3,"file":"geodesy-fn.umd.min.js","sources":["../src/common.ts","../src/dms.ts","../src/spherical.ts"],"sourcesContent":["export const DEFAULT_RADIUS = 6371e3;\n\nexport function equals(position1: GeoJSON.Position, position2: GeoJSON.Position): boolean {\n  if (Math.abs(position1[0] - position2[0]) > Number.EPSILON) return false;\n  if (Math.abs(position1[1] - position2[1]) > Number.EPSILON) return false;\n\n  return true;\n}\n\nexport function toRadians(value: number): number {\n  return value / 180 * Math.PI;\n}\n\nexport function toDegrees(value: number): number {\n  return value / Math.PI * 180;\n}\n","export function wrap360(value: number): number {\n  return (value + 360) % 360\n}\n","import { DEFAULT_RADIUS, equals, toRadians, toDegrees } from './common.js';\nimport { wrap360 } from './dms.js';\n\n/**\n * Returns the distance along the surface of the earth from start point to destination point.\n *\n * Uses haversine formula: a = sin²(Δφ/2) + cosφ1·cosφ2 · sin²(Δλ/2); d = 2 · atan2(√a, √(a-1)).\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {GeoJSON.Position} destination - Longitude/latitude of destination point.\n * @param   {number} [radius] - Radius of earth (defaults to mean radius in metres).\n * @returns {number} Distance between start point and destination point, in same units as radius.\n *\n * @example\n *   const p1 = [0.119, 52.205];\n *   const p2 = [2.351, 48.857];\n *   const d = distance(p1, p2);         // 404.3×10³ m\n *   const m = distanceTo(p1, p2, 3959); // 251.2 miles\n */\nexport function distance(start: GeoJSON.Position, destination: GeoJSON.Position, radius: number = DEFAULT_RADIUS): number {\n  // a = sin²(Δφ/2) + cos(φ1)⋅cos(φ2)⋅sin²(Δλ/2)\n  // δ = 2·atan2(√(a), √(1−a))\n  // see mathforum.org/library/drmath/view/51879.html for derivation\n\n  const R = radius;\n  const φ1 = toRadians(start[1]),       λ1 = toRadians(start[0]);\n  const φ2 = toRadians(destination[1]), λ2 = toRadians(destination[0]);\n  const Δφ = φ2 - φ1;\n  const Δλ = λ2 - λ1;\n\n  const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const d = R * c;\n\n  return d;\n}\n\n/**\n * Returns the initial bearing from start point to destination point.\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {GeoJSON.Position} destination - Longitude/latitude of destination point.\n * @returns {number} Initial bearing in degrees from north (0°..360°).\n *\n * @example\n *   const p1 = [0.119, 52.205];\n *   const p2 = [2.351, 48.857];\n *   const b1 = initialBearing(p1, p2); // 156.2°\n */\nexport function initialBearing(start: GeoJSON.Position, destination: GeoJSON.Position): number {\n  if (equals(start, destination)) return NaN; // coincident points\n\n  // tanθ = sinΔλ⋅cosφ2 / cosφ1⋅sinφ2 − sinφ1⋅cosφ2⋅cosΔλ\n  // see mathforum.org/library/drmath/view/55417.html for derivation\n\n  const φ1 = toRadians(start[1]);\n  const φ2 = toRadians(destination[1]);\n  const Δλ = toRadians(destination[0] - start[0]);\n\n  const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);\n  const y = Math.sin(Δλ) * Math.cos(φ2);\n  const θ = Math.atan2(y, x);\n\n  const bearing = toDegrees(θ);\n\n  return wrap360(bearing);\n}\n\n/**\n * Returns final bearing arriving at destination point from ‘this’ point; the final bearing will\n * differ from the initial bearing by varying degrees according to distance and latitude.\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {GeoJSON.Position} destination - Longitude/latitude of destination point.\n * @returns {number} Final bearing in degrees from north (0°..360°).\n *\n * @example\n *   const p1 = [0.119, 52.205];\n *   const p2 = [2.351, 48.857];\n *   const b2 = finalBearing(p1, p2); // 157.9°\n */\nexport function finalBearing(start: GeoJSON.Position, destination: GeoJSON.Position): number {\n  // get initial bearing from destination point to this point & reverse it by adding 180°\n\n  const bearing = initialBearing(destination, start) + 180;\n\n  return wrap360(bearing);\n}\n\n/**\n * Returns the midpoint between start point and destination point.\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {GeoJSON.Position} destination - Longitude/latitude of destination point.\n * @returns {GeoJSON.Position} Midpoint between this point and destination point.\n *\n * @example\n *   const p1 = [0.119, 52.205];\n *   const p2 = [2.351, 48.857];\n *   const pMid = midpoint(p1, p2); // [1.2746, 50.5363]\n */\nexport function midpoint(start: GeoJSON.Position, destination: GeoJSON.Position): GeoJSON.Position {\n  // φm = atan2( sinφ1 + sinφ2, √( (cosφ1 + cosφ2⋅cosΔλ)² + cos²φ2⋅sin²Δλ ) )\n  // λm = λ1 + atan2(cosφ2⋅sinΔλ, cosφ1 + cosφ2⋅cosΔλ)\n  // midpoint is sum of vectors to two points: mathforum.org/library/drmath/view/51822.html\n\n  const φ1 = toRadians(start[1]);\n  const λ1 = toRadians(start[0])\n  const φ2 = toRadians(destination[1]);\n  const Δλ = toRadians(destination[0] - start[0]);\n\n  // get cartesian coordinates for the two points\n  const A = { x: Math.cos(φ1), y: 0, z: Math.sin(φ1) }; // place point A on prime meridian y=0\n  const B = { x: Math.cos(φ2)*Math.cos(Δλ), y: Math.cos(φ2)*Math.sin(Δλ), z: Math.sin(φ2) };\n\n  // vector to midpoint is sum of vectors to two points (no need to normalise)\n  const C = { x: A.x + B.x, y: A.y + B.y, z: A.z + B.z };\n\n  const φm = Math.atan2(C.z, Math.sqrt(C.x*C.x + C.y*C.y));\n  const λm = λ1 + Math.atan2(C.y, C.x);\n\n  const lat = toDegrees(φm);\n  const lon = toDegrees(λm);\n\n  return [lon, lat];\n}\n\n/**\n * Returns the destination point from start point having travelled the given distance on the\n * given initial bearing (bearing normally varies around path followed).\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n * @param   {number} bearing - Initial bearing in degrees from north.\n * @param   {number} [radius] - Radius of earth (defaults to mean radius in metres).\n * @returns {GeoJSON.Position} Destination point.\n *\n * @example\n *   const p1 = [-0.00147, 51.47788];\n *   const p2 = destinationPoint(p1, 7794, 300.7); // [0.0983, 51.5136]\n */\nexport function destinationPoint(start: GeoJSON.Position, distance: number, bearing: number, radius: number = DEFAULT_RADIUS): GeoJSON.Position {\n  // sinφ2 = sinφ1⋅cosδ + cosφ1⋅sinδ⋅cosθ\n  // tanΔλ = sinθ⋅sinδ⋅cosφ1 / cosδ−sinφ1⋅sinφ2\n  // see mathforum.org/library/drmath/view/52049.html for derivation\n\n  const δ = distance / radius; // angular distance in radians\n  const θ = toRadians(bearing);\n\n  const φ1 = toRadians(start[1]), λ1 = toRadians(start[0]);\n\n  const sinφ2 = Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ);\n  const φ2 = Math.asin(sinφ2);\n  const y = Math.sin(θ) * Math.sin(δ) * Math.cos(φ1);\n  const x = Math.cos(δ) - Math.sin(φ1) * sinφ2;\n  const λ2 = λ1 + Math.atan2(y, x);\n\n  const lat = toDegrees(φ2);\n  const lon = toDegrees(λ2);\n\n  return [lon, lat];\n}\n"],"names":["toRadians","value","Math","PI","toDegrees","wrap360","initialBearing","start","destination","position1","position2","abs","Number","EPSILON","NaN","x","cos","sin","y","atan2","distance","bearing","radius","DEFAULT_RADIUS","asin","lat","R","a","sqrt","A","C","z"],"mappings":"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"}